---
layout: post
title: The Twelve Factor Application
categories: [Modern Design, Cloud, Microservices]
---

A widely accepted methodology for constructing modern applications is the [Twelve-Factor Application](https://12factor.net). It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments. Special attention is given to portability across environments and declarative automation.

While applicable to any web applicaion, many practitioners consider it as a solid foundation for building cloud-native apps. Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.

## The Twelve-Factor Methodology

**1. Code Base:** A single code base for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments (QA, Staging, Production). 

**2. Dependencies:** Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.

**3. Configurations:** Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code. The same deployment can propagate across environments with the correct configuration applied.

**4. Backing Services:** Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL. Doing so decouples the resource from the application, enabling it to be interchangeable.

**5. Build, Release, Run:** Each release must enforce a strict separation across the build, release, and run stages. Each should be tagged with a unique ID and support the ability to roll back. Modern CI/CD systems help fulfill this principle. 

**6. Processes:** Each microservice should execute in its own process, isolated from other running services. Externalize required state to a backing service such as a distributed cache or data store.

**7. Port Binding:** Each microservice should be self-contained with its interfaces and functionality exposed on its own port. Doing so provides isolation from other microservices.

**8. Concurrency:** Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.

**9. Disposability:** Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement.

**10. Dev/Prod Parity:** Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts. Here, the adoption of containers can greatly contribute by promoting the same execution environment.

**11. Logging:** Treat logs generated by microservices as event streams. Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.

**12. Admin Processes:** Run administrative/management tasks as one-off processes. Tasks can include data cleanup and pulling analytics for a report. Tools executing these tasks should be invoked from the production environment, but separately from the application.

Learn more about the Twelve-Factor Application at [https://12factor.net](https://12factor.net)






